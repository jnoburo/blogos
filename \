use std::collections::hash_map::IntoIter;

use ndarray::Data;

pub type InputPointer = (usize, bool);

pub enum BooleanOperation {
    And,
    Or,
}

impl BooleanOperation {
    pub const fn negate(&self) -> Self {
        match self {
            Self::And => Self::Or,
            Self::Or => Self::And,
        }
    }
}

pub struct Instruction {
    a: InputPointer,
    b: InputPointer,
    operation: BooleanOperation,
}

impl Instruction {
    pub const fn new(a: InputPointer, b: InputPointer, operation: BooleanOperation) -> Instruction {
        Instruction { a, b, operation }
    }

    pub const fn negate(&self) -> Self {
        Instruction {
            a: (self.a.0, !self.a.1),
            b: (self.b.0, !self.b.1),
            operation: self.operation.negate(),
        }
    }

    pub fn eval(&self, inputs: Vec<bool>) -> bool {
        let con1: bool = (self.a.1 == inputs[self.a.0]);
        let con2: bool = (self.b.1 == inputs[self.b.0]);
        match self.operation {
            BooleanOperation::And => return con1 && con2,
            BooleanOperation::Or => return con1 || con2,
        }
    }
}

// Most basic comparison possible, simply between two raw inputs. From this all
// other comparisons are built.
pub struct RawComparison {
    a: InputPointer,
    b: InputPointer,
    operation: BooleanOperation,
}

pub enum TreeInputs {
    Power,
    Tree(usize),
    Instruction(Instruction),
}

// Comparisons are structured as a flat vector. Each step contains two values and a boolean
// operation. The comparison fills depth first until it is able to reach the circuit input
// pointers. The circuit then backtracks to the closest unfilled space and repeats this process
// until the entirety of the comparison tree is filled. If at any point it bottoms out and does not
// have a valid next step, the comparison will error.
//
// Once the entire tree is built, we can begin pruning it in order to remove redundant comparisons
// and substitute larger comparisons for more efficient ones.
pub struct CompTree {
    inputs: usize,
    data: Vec<(BooleanOperation, Option<RawComparison>)>,
    operation: BooleanOperation,
}

impl CompTree {
    pub fn build(input_count: usize, TreeInputs: Vec<TreeInputs>, operation: BooleanOperation) -> Self {

        let instructions

        todo!()
    }
}
